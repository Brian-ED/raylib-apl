âŸ¨
  HeaderToFFI  # Read string ğ•© and optional function prefix ğ•¨, outputs metaprogrammed file as string
  ToFFI        # turns header data from ParseHeader into ffi file characters
  ParseHeader  # Read string ğ•© and optional function prefix ğ•¨, outputs header data
  ToPrettyJson # Read header data from ParseHeader and makes a pretty json file
âŸ©â‡

âŸ¨ParseJSONâ‡ParseâŸ© â† â€¢Import "../imports/c-header-to-bqn-ffi/json.bqn"

# util functions
nl â† @+10 # newline
wnl â† @+13 # windows newline prefix
Box â† âŸ¨âŸ©âŠ¸â‰¡â—¶âŸ¨>â‹„â†•0â€¿0âŸ©âŠ¢Â»Â¨âŸœ<' 'â¥ŠËœ0âŒˆÂ´â‰ Â¨
LowerNames â† +âŸœ(32Ã—1="A["âŠ¸â‹)âŒ¾(1â†‘â‰1âŠ¢)âŸ(âŸ¨âŸ©âŠ¸â‰¢)
_MetaParse â† {âˆ¾Ë˜Â´[ğ•—,ğ•¨]{Fâ€¿wğ•Šğ•©:<wâŠ¸âˆ¾Ë˜Box Fğ•©}Ë˜â—‹â‰â†•âˆ˜0â€¿3âŸ(âŸ¨âŸ©âŠ¸â‰¡)ğ•©}

remap â† {ğ•âŒ¾âŒ½}{ğ•ğ•}Â´{(ğ•¨âŠ¸â‰¡âˆ§"*"â‰¡1â†‘âŠ£)â—¶âŸ¨â‹ˆâ‹„ğ•©â‹ˆËœ1â†“âŠ£âŸ©Â´}Â´Â¨âŸ¨
  "unsigned char"  â€¿"ustr"
  "char"           â€¿"str"
  "void"           â€¿"ptr"
  "rAudioBuffer"   â€¿"ptr"
  "rAudioProcessor"â€¿"ptr"
âŸ©
constTextâ†"const "

SwitchOrder â† {âŒ½âŒ¾((ğ•©âˆŠ'0'+â†•10)âŠ¸/)1âŠ¸âŒ½âŒ¾((ğ•©âˆŠ"[]")âŠ¸/)ğ•©}âŒ½

shortendStructNamesâ†[
  "v2"â€¿"Vector2"
  "v3"â€¿"Vector3"
  "v4"â€¿"Vector4"
]

typeReplacements â† â‰shortendStructNamesâˆ¾[
  # remove since they're not defined
  "ptr"â€¿"AudioCallback"
  "ptr"â€¿"LoadFileDataCallback"
  "ptr"â€¿"LoadFileTextCallback"
  "ptr"â€¿"SaveFileDataCallback"
  "ptr"â€¿"SaveFileTextCallback"
  "ptr"â€¿"TraceLogCallback"

  "f8" â€¿"double"
  "i8" â€¿"long"
  "f"  â€¿"float"
  "i"  â€¿"int"
  "ptr"â€¿"..."
  "u"  â€¿"unsigned int"
  "u1" â€¿"char"
  "u1" â€¿"unsigned char"
  "u2" â€¿"unsigned short"
  " "  â€¿"void"
]

# turns header data from ParseHeader into ffi file characters
# ğ•¨ is an optional name mapping, used so you can rename functions and fix name collisions
#   If the resulting name collides with a already-defined name, it errors.
## Example1: ToFFI ParseHeader file.h
## Example2: [âŸ¨"bad_name"âŸ©â‹„âŸ¨"CoolName"âŸ©] ToFFI ParseHeader file.h
ToFFI â† {ğ•¨ğ•Šdata: nameMapping â† ğ•¨âŠ£â†•2â€¿0
  # if there are no collisions it's all fine
  # but if there are collisions it errors,
  # unless you provide the header to ffi script a input
  # that's a mapping of c names to bqn names

  # TODO check validity of names in the mapping

  MapNames â† {
    [oldâ‹„new]â†nameMapping
    (newâŠËœoldâŠ¸âŠ)âŒ¾((ğ•©âˆŠold)âŠ¸/)ğ•©
  }

  mapArgTypes â† {
    [bqn,c] â† typeReplacements
    {
      constsâ†constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
      s â† constsâˆ¨Â¬âˆ¨Â´Â¨'*'=ğ•©
      cleanedâ†constTextâŠ¸âˆ¾â¼Â¨âŒ¾(constsâŠ¸/)ğ•©
      iâ†âŠ‘(<"const char *")âŠ¸âˆŠğ•©
      [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapË˜ (â†•0â€¿2)âˆ¾Â´ âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸(Â¬âŠ¸/âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/âŠ¸â‹ˆSwitchOrderâˆ˜/)Â¨cleaned
      replaced â† kept {MapNamesâŒ¾â‹ˆğ•¨}âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
      removed {(ğ•¨âŠ‘"=<")Â¨âŒ¾(('*'=ğ•©)âŠ¸/)ğ•©}Â¨Ëœâ†©s
      removed {""ğ•Šğ•©:ğ•©;'"'â‰¡âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾('"'âŠ¸âˆ¾â¼)ğ•©;"('"âˆ¾ğ•¨âˆ¾"',"âˆ¾ğ•©âˆ¾')'}Â¨replaced
    }
  }

  AddRemoved â† {
    ""ğ•Šğ•©:ğ•©;
    "'"â‰¡â—‹âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾((âŠ‘"'")âŠ¸âˆ¾â¼)ğ•©;
    âŠ‘"<=>"âˆŠËœâŠ‘ğ•¨? "'"âˆ¾ğ•¨âˆ¾"',"âˆ¾ğ•©;
    ğ•©âˆ¾",'"âˆ¾ğ•¨âˆ¾"'"
  }

  MapStructTypes â† {
    [bqn,c] â† typeReplacements
    cleanedâ†constTextâŠ¸âˆ¾â¼Â¨âŒ¾((constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©)âŠ¸/)ğ•©
    mask â† âˆ¨`âˆ˜âˆŠâŸœ"[*<>"Â¨cleaned # TODO: I don't remember why "=" is missing
    [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapË˜> mask{âŸ¨âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/ğ•©/ËœÂ¬ğ•¨ â‹„ SwitchOrder ğ•¨/ğ•©âŸ©}Â¨cleaned
    replaced â† kept MapNamesâŒ¾â‹ˆâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
    ({'='Â¨âŒ¾((ğ•©='*')âŠ¸/)ğ•©}Â¨ removed) AddRemovedÂ¨ replaced
  }

  MapStructNames â† {
    [bqn,c]â†â‰shortendStructNames
    ğ•©MapNamesâŒ¾â‹ˆâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠğ•©)âŠbqnâˆ¾0
  }

  MapFuncReturnType â† {
    [bqn,c] â† typeReplacements
    cleanedâ†ğ•©â†“ËœÂ¨constTextâ‰ âŠ¸Ã—constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapË˜> âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸(Â¬âŠ¸/Â¯1âŠ¸â†“âŸ(" "â‰¡Â¯1âŠ¸â†‘)âŠ¸â‹ˆSwitchOrderâˆ˜/)Â¨cleaned
    replaced â† kept MapNamesâŒ¾â‹ˆâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
    remMask â† âŠ‘Â¨'*'âŠ¸âˆŠÂ¨ removed
    {'('âˆ¾ğ•©âˆ¾')'}âŸ(âˆ¨Â´",âŠ£"âŠ¸âˆŠ)Â¨"ptrâŠ£"âŠ¸âˆ¾âŸ(("ustr"â‰¡Â¯4âŠ¸â†‘)âˆ¨"str"â‰¡Â¯3âŠ¸â†‘)Â¨ "ptr"Â¨âŒ¾(remMaskâŠ¸/) removed AddRemovedÂ¨ replaced
  }

  definesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functionsâ†{
    !ğ•©âŠ£ËâŠ¸â‰¡"defines"â€¿"structs"â€¿"aliases"â€¿"enums"â€¿"callbacks"â€¿"functions"
    âŠ¢ËÂ¨Â¨âŒ¾(0â€¿1â€¿3â€¿4â€¿5âŠ¸âŠ)âŠ¢Ëğ•©
  } ParseJSON ToPrettyJson data
  functions âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨â†©

  top â† âŸ¨
    "â THIS TEXT HAS BEEN AUTOGENERATED"
    ""
  âŸ©
  typedefs â† âŸ¨
    "bool â† 'I1'"
    "c    â† 'I1'"
    "i    â† 'I4'"
    "f    â† 'F4'"
    "u    â† 'U4'"
    "i1   â† 'I1'"
    "u1   â† 'U1'"
    "u8   â† 'U8'"
    "ptr  â† ,'P'"
    "f8   â† 'F8'"
    "i8   â† 'I8'"
    "u2   â† 'U2'"
    "ustr â† '=C1'"
    "str  â† '=0C1'"
  âŸ©
  initTradFnHeader â† âŸ¨
    "â Mode is either 3:All changes, 2:only manual changes 1:only automatic changes, or 0: no changes"
    "âˆ‡{mode} Init pathToRaylibDotAPLN"
    ""
    "pathToRaylibDotAPLN â† (âŠ¢,'/'/â¨'/'â‰¢âŠƒâ¤âŒ½)(âŠ¢,'.'/â¨0=â‰¢â¤âŠ¢),pathToRaylibDotAPLN"
    ""
    "__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__ â† 0 â•FIX pathToRaylibDotAPLN,'../non-link/setup.apln.hide'"
    "'' â•NS ('__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__.',âŠ¢)Â¨__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__.â•NL Â¯3"
    "'' â•NS ('__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__.',âŠ¢)Â¨__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__.â•NL Â¯2"
    "'' â•NS ('__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__.',âŠ¢)Â¨__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__.â•NL Â¯9"
    "â•EX '__PLEASE_DO_NOT_REPLACE_EXISTING_VAR__'"
    ""
    "pathToBinary â† lib"
    ":If 0=â•NC 'mode'"
    "  mode â† 3 â Default is All changes"
    ":EndIf"
    ""
  âŸ©
  bottom â† âŸ¨
    "âˆ‡"
  âŸ©

  definesDone â† {
    exclTypes  â† "GUARD"â€¿"MACRO"â€¿"UNKNOWN"â€¿"FLOAT_MATH"â€¿"COLOR"
    filtered â† {ğ•Šnameâ€¿typeâ€¿valâ€¿desc:
      Â¬âˆ¨Â´âŸ¨"PI"â‰¡name, âˆ¨Â´typeâŠ¸â‰¡Â¨exclTypes, âŸ¨âŸ©â‰¡val âŸ©
    }Ë˜âŠ¸/(â†•0â€¿4)âˆ¾Â´defines
    OnItem â† {"''"âŸ(""""""âŠ¸â‰¡)ğ•©}âŒ¾(0â€¿Â¯1âŠ¸âŠ)
    <Ë˜""â€¿""â€¿" â† "â€¿" â "âŸ¨MapNames,âŸ¨âŸ©Â¨,OnItemÂ¨â€¢ReprÂ¨,âŠ¢âŸ©_MetaParse filtered
  }

  enumsDone â† {
    [names,descriptions,values]â†â‰(â†•0â€¿3)âˆ¾Â´enums
    tabled â† >Â¨âŠ¢ËÂ¨Â¨ values
    bodys â† (<Ë˜"  "â€¿" â† "â€¿"  â "âŸ¨MapNames,â€¢ReprÂ¨,âŠ¢âŸ©_MetaParseâŠ¢)Â¨tabled
    headers â† ":Namespace "âŠ¸âˆ¾Â¨ (MapNames names) âˆ¾Â¨<Ë˜" â "âŠ¸âˆ¾Ë˜Box descriptions
    âŸ¨âŸ©âˆ¾Â´headers<âŠ¸âˆ¾Â¨âˆ¾âŸœâŸ¨":EndNamespace"â‹„""âŸ©Â¨bodys
  }

  structsDone â† typedefsâˆ¾initTradFnHeaderâˆ¾Ëœ{
    [names,descriptions,fields]â†â‰(â†•0â€¿3)âˆ¾Â´structs
    headers â† (MapStructNames names) âˆ¾âŸœ" â† â¬ â "âŠ¸âˆ¾Â¨ descriptions
    bodys â† names{<Ë˜("  "âˆ¾(MapStructNamesâŒ¾â‹ˆğ•¨)âˆ¾",â†âŠ‚ ")â€¿" â "â€¿"  â "âŸ¨MapStructTypes,âŠ¢,âŠ¢âŸ©_MetaParse âŸ¨"'"(âŠ£âˆ¾Ëœâˆ¾)'â‹„'âˆ¾ğ•¨â‹„""â‹„""âŸ©âˆ¾ >ğ•©}Â¨âŠ¢ËÂ¨Â¨fields
    assembled â† headers ""âŠ¸â‹ˆâŠ¸âˆ¾Â¨ bodys
    aliasLinesâ†Â»âŠ¸âˆ¨âˆ˜â‰ âŸœ' 'âŠ¸/Â¨<Ë˜""â€¿" â† "â€¿" â "âŸ¨MapNames,MapArgTypes,âŠ¢âŸ©_MetaParse âŒ½âŒ¾(2âŠ¸â†‘)Ë˜>âŠ¢ËÂ¨aliases
    pâ†âŠ‘Â¨âŠ¢ËÂ¨aliases
    âˆ¾ âˆ¾âˆ¾âŸœ(â‹ˆâ‹ˆ)Â¨âŸœaliasLinesâŒ¾(Â¯1âŠ¸â†“)assembledâŠ”Ëœ+`Â»+Ëpâ‰¡âŒœnames
  }
  functionsDone â† {
    sLines â† 0Â¨functions

    returnTypes â† {funcNameâ€¿descriptionâ€¿retTypeâ€¿args: retType}Â¨functions

    s2Lines â† 1Â¨returnTypes
    !Â¬âˆ¨Â´s2Linesâˆ§sLines # I don't want the lines to collide

    [namesâ‹„descâ‹„returnsâ‹„argTypesâ‹„argNames] â† {
      (3â†‘ğ•©)âˆ¾â‰{<Ë˜â‰(â†•0â€¿2)âˆ¾Â´âŠ¢ËÂ¨<â¼ğ•©}Ë˜âŠ¢Ëğ•©
    }â‰(1+s2Linesâˆ¨sLines)/(â†•0â€¿4)âˆ¾Â´functions

    sAllLinesExtended â† (â†•âˆ˜â‰ âŠ¸+âŒ¾/â†‘Ëœ+Â´+â‰ )s2Linesâˆ¨sLines
    s1LinesExtendedâ€¿s2LinesExtended â† s2Lines{((+Â´+â‰ )ğ•©+ğ•¨)â†‘ğ•¨âŠ¸{(Â¬ğ•©âˆŠ/ğ•¨)/ğ•©+â†•â‰ ğ•©}âŒ¾/ğ•¨+ğ•©}{ğ”½â‹ˆğ”½Ëœ}sLines

    (Â»s2LinesExtended)âŠ¸/<Ë˜""â€¿" â† "â€¿" R('"â€¿" ("â€¿")) â"â€¿" â "âŸ¨
      âˆ¾âŸœ"RAYLIB"Â¨âŒ¾((Â»s2LinesExtended)âŠ¸/)Â·âˆ¾âŸœ"Ref"Â¨âŒ¾((0Â»s1LinesExtended)âŠ¸/)MapNamesÂ¨
      ""Â¨âŒ¾((Â»s2LinesExtended)âŠ¸/) MapFuncReturnType # Returns
      âˆ¾âŸœ"'"Â¨Â·âˆ¾âŸœ"RetPtr"Â¨âŒ¾((Â»s2LinesExtended)âŠ¸/)Â·âˆ¾âŸœ"Ref"Â¨âŒ¾((0Â»s1LinesExtended)âŠ¸/)MapNamesÂ¨ # Function Names
      { # Argument types
        returnTypes â† MapArgTypes returnTypes/Ëœ1+s2Linesâˆ¨sLines
        aâ†returnTypes <âˆ˜{"('="â‰¡3â†‘ğ•©?"ptr"; "('>',"âˆ¾ğ•©âˆ¾")"}âŠ¸âˆ¾Â¨âŒ¾(((" "âŠ¸â‰¢Â¨returnTypes)âˆ§0Â»s2LinesExtended)âŠ¸/) MapArgTypesÂ¨ğ•©
        bâ† (2âŒŠâ‰ )â—¶âŸ¨â‹ˆ"â¬"â‹„âŸ¨",âŠ‚"âŸ©âˆ¾âŠ¢â‹„âŠ¢âŸ©Â¨a
        (1â†“Â·âˆ¾' 'âŠ¸âˆ¾Â¨)Â¨b
      }
      (âˆ¾' 'âŠ¸âˆ¾Â¨)Â¨ # Argument names turned into comments
      âŠ¢ # Function comment
    âŸ©_MetaParse â‰[namesâ‹„returnsâ‹„namesâ‹„argTypesâ‹„argNamesâ‹„desc]
  }
  1â†“âˆ¾nlâˆ¾Â¨topâˆ¾bottomâˆ¾Ëœâˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/Â¨âˆ¾1â†“âˆ¾âŸ¨""âŸ©âŠ¸â‹ˆÂ¨definesDoneâ€¿enumsDoneâ€¿structsDoneâ€¿functionsDone
}

âŸ¨ParseHeader, ToPrettyJsonâŸ©â‡â€¢Import"../imports/c-header-to-bqn-ffi/parse.bqn"

HeaderToFFI â† ToFFI ParseHeader
