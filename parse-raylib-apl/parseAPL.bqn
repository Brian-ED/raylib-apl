⟨
  HeaderToFFI  # Read string 𝕩 and optional function prefix 𝕨, outputs metaprogrammed file as string
  ToFFI        # turns header data from ParseHeader into ffi file characters
  ParseHeader  # Read string 𝕩 and optional function prefix 𝕨, outputs header data
  ToPrettyJson # Read header data from ParseHeader and makes a pretty json file
  GetFiles
  FFISetup
  HandleEverything
  MakeReplacement
⟩⇐

⟨ParseJSON⇐Parse⟩ ← •Import "../imports/c-header-to-bqn-ffi/json.bqn"

# util functions
nl ← @+10 # newline
wnl ← @+13 # windows newline prefix
Box ← ⟨⟩⊸≡◶⟨>⋄↕0‿0⟩⊢»¨⟜<' '⥊˜0⌈´≠¨
LowerNames ← +⟜(32×1="A["⊸⍋)⌾(1↑⎉1⊢)⍟(⟨⟩⊸≢)
_MetaParse ← {∾˘´[𝕗,𝕨]{F‿w𝕊𝕩:<w⊸∾˘Box F𝕩}˘○⍉↕∘0‿3⍟(⟨⟩⊸≡)𝕩}

remap ← {𝕏⌾⌽}{𝕎𝕏}´{(𝕨⊸≡∧"*"≡1↑⊣)◶⟨⋈⋄𝕩⋈˜1↓⊣⟩´}´¨⟨
  "unsigned char"  ‿"ustr"
  "char"           ‿"str"
  "void"           ‿"ptr"
  "rAudioBuffer"   ‿"ptr"
  "rAudioProcessor"‿"ptr"
⟩
constText←"const "

SwitchOrder ← {⌽⌾((𝕩∊'0'+↕10)⊸/)1⊸⌽⌾((𝕩∊"[]")⊸/)𝕩}⌽

shortendStructNames←[
  "v2"‿"Vector2"
  "v3"‿"Vector3"
  "v4"‿"Vector4"
]

typeReplacements ← ⍉shortendStructNames∾[
  # remove since they're not defined
  "ptr"‿"AudioCallback"
  "ptr"‿"LoadFileDataCallback"
  "ptr"‿"LoadFileTextCallback"
  "ptr"‿"SaveFileDataCallback"
  "ptr"‿"SaveFileTextCallback"
  "ptr"‿"TraceLogCallback"

  "f8" ‿"double"
  "i8" ‿"long"
  "f"  ‿"float"
  "i"  ‿"int"
  "ptr"‿"..."
  "u"  ‿"unsigned int"
  "u1" ‿"char"
  "u1" ‿"unsigned char"
  "u2" ‿"unsigned short"
  " "  ‿"void"
]

# turns header data from ParseHeader into ffi file characters
# 𝕨 is an optional name mapping, used so you can rename functions and fix name collisions
#   If the resulting name collides with a already-defined name, it errors.
## Example1: ToFFI ParseHeader file.h
## Example2: [⟨"bad_name"⟩⋄⟨"CoolName"⟩] ToFFI ParseHeader file.h
ToFFI ← {𝕨𝕊data: nameMapping ← 𝕨⊣↕2‿0
  # if there are no collisions it's all fine
  # but if there are collisions it errors,
  # unless you provide the header to ffi script a input
  # that's a mapping of c names to bqn names

  # TODO check validity of names in the mapping

  MapNames ← {
    [old⋄new]←nameMapping
    (new⊏˜old⊸⊐)⌾((𝕩∊old)⊸/)𝕩
  }

  mapArgTypes ← {
    [bqn,c] ← typeReplacements
    {
      consts←constText⊸(⊣≡≠⊸↑)¨𝕩
      s ← consts∨¬∨´¨'*'=𝕩
      cleaned←constText⊸∾⁼¨⌾(consts⊸/)𝕩
      i←⊑(<"const char *")⊸∊𝕩
      [kept,removed] ← 2‿∘⥊⍉Remap˘ (↕0‿2)∾´ ∨`∘∊⟜"[*"⊸(¬⊸/∨`⌾⌽∘≠⟜' '⊸/⊸⋈SwitchOrder∘/)¨cleaned
      replaced ← kept {MapNames⌾⋈𝕨}⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
      removed {(𝕨⊑"=<")¨⌾(('*'=𝕩)⊸/)𝕩}¨˜↩s
      removed {""𝕊𝕩:𝕩;'"'≡⊑𝕩?𝕨⊸∾⌾('"'⊸∾⁼)𝕩;"('"∾𝕨∾"',"∾𝕩∾')'}¨replaced
    }
  }

  AddRemoved ← {
    ""𝕊𝕩:𝕩;
    "'"≡○⊑𝕩?𝕨⊸∾⌾((⊑"'")⊸∾⁼)𝕩;
    ⊑"<=>"∊˜⊑𝕨? "'"∾𝕨∾"',"∾𝕩;
    𝕩∾",'"∾𝕨∾"'"
  }

  MapStructTypes ← {
    [bqn,c] ← typeReplacements
    cleaned←constText⊸∾⁼¨⌾((constText⊸(⊣≡≠⊸↑)¨𝕩)⊸/)𝕩
    mask ← ∨`∘∊⟜"[*<>"¨cleaned # TODO: I don't remember why "=" is missing
    [kept,removed] ← 2‿∘⥊⍉Remap˘> mask{⟨∨`⌾⌽∘≠⟜' '⊸/𝕩/˜¬𝕨 ⋄ SwitchOrder 𝕨/𝕩⟩}¨cleaned
    replaced ← kept MapNames⌾⋈∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
    ({'='¨⌾((𝕩='*')⊸/)𝕩}¨ removed) AddRemoved¨ replaced
  }

  MapStructNames ← {
    [bqn,c]←⍉shortendStructNames
    𝕩MapNames⌾⋈∘⊣⍟(0⊸≡)¨(c⊐𝕩)⊏bqn∾0
  }

  MapFuncReturnType ← {
    [bqn,c] ← typeReplacements
    cleaned←𝕩↓˜¨constText≠⊸×constText⊸(⊣≡≠⊸↑)¨𝕩
    [kept,removed] ← 2‿∘⥊⍉Remap˘> ∨`∘∊⟜"[*"⊸(¬⊸/¯1⊸↓⍟(" "≡¯1⊸↑)⊸⋈SwitchOrder∘/)¨cleaned
    replaced ← kept MapNames⌾⋈∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
    remMask ← ⊑¨'*'⊸∊¨ removed
    {'('∾𝕩∾')'}⍟(∨´",⊣"⊸∊)¨"ptr⊣"⊸∾⍟(("ustr"≡¯4⊸↑)∨"str"≡¯3⊸↑)¨ "ptr"¨⌾(remMask⊸/) removed AddRemoved¨ replaced
  }

  defines‿structs‿aliases‿enums‿callbacks‿functions←{
    !𝕩⊣˝⊸≡"defines"‿"structs"‿"aliases"‿"enums"‿"callbacks"‿"functions"
    ⊢˝¨¨⌾(0‿1‿3‿4‿5⊸⊏)⊢˝𝕩
  } ParseJSON ToPrettyJson data
  functions ∾⟜⟨⟨⟩⟩⍟(3=≠)¨↩

  top ← ⟨
    "⍝ THIS TEXT HAS BEEN AUTOGENERATED"
    ""
  ⟩
  typedefs ← ⟨
    "bool ← 'I1'"
    "c    ← 'I1'"
    "i    ← 'I4'"
    "f    ← 'F4'"
    "u    ← 'U4'"
    "i1   ← 'I1'"
    "u1   ← 'U1'"
    "u8   ← 'U8'"
    "ptr  ← ,'P'"
    "f8   ← 'F8'"
    "i8   ← 'I8'"
    "u2   ← 'U2'"
    "ustr ← '=C1'"
    "str  ← '=0C1'"
  ⟩
  initTradFnHeader ← ⟨
    "⍝ Mode is either 3:All changes, 2:only manual changes 1:only automatic changes, or 0: no changes"
    "∇{mode} Init pathToRaylibDotAPLN ;import"
    ""
    "pathToRaylibDotAPLN ← (⊢,'/'/⍨'/'≢⊃⍤⌽)(⊢,'.'/⍨0=≢⍤⊢),pathToRaylibDotAPLN"
    ""
    "import ← 0 ⎕FIX pathToRaylibDotAPLN,'../non-link/setup.apln.hide'"
    "'' ⎕NS 'import.'∘,¨import.⎕NL-2 3 9"
    "⎕EX 'import'"
    ""
    "pathToBinary ← lib"
    ":If 0=⎕NC 'mode'"
    "  mode ← 3 ⍝ Default is All changes"
    ":EndIf"
    ""
  ⟩
  bottom ← ⟨
    "∇"
  ⟩

  definesDone ← {
    exclTypes  ← "GUARD"‿"MACRO"‿"UNKNOWN"‿"FLOAT_MATH"‿"COLOR"
    filtered ← {𝕊name‿type‿val‿desc:
      ¬∨´⟨"PI"≡name, ∨´type⊸≡¨exclTypes, ⟨⟩≡val ⟩
    }˘⊸/(↕0‿4)∾´defines
    OnItem ← {"''"⍟(""""""⊸≡)𝕩}⌾(0‿¯1⊸⊏)
    <˘""‿""‿" ← "‿" ⍝ "⟨MapNames,⟨⟩¨,OnItem¨•Repr¨,⊢⟩_MetaParse filtered
  }

  enumsDone ← {
    [names,descriptions,values]←⍉(↕0‿3)∾´enums
    tabled ← >¨⊢˝¨¨ values
    bodys ← (<˘"  "‿" ← "‿"  ⍝ "⟨MapNames,•Repr¨,⊢⟩_MetaParse⊢)¨tabled
    headers ← ":Namespace "⊸∾¨ (MapNames names) ∾¨<˘" ⍝ "⊸∾˘Box descriptions
    ⟨⟩∾´headers<⊸∾¨∾⟜⟨":EndNamespace"⋄""⟩¨bodys
  }

  structsDone ← typedefs∾initTradFnHeader∾˜{
    [names,descriptions,fields]←⍉(↕0‿3)∾´structs
    headers ← (MapStructNames names) ∾⟜" ← ⍬ ⍝ "⊸∾¨ descriptions
    bodys ← names{<˘("  "∾(MapStructNames⌾⋈𝕨)∾",←⊂ ")‿" ⍝ "‿"  ⍝ "⟨MapStructTypes,⊢,⊢⟩_MetaParse ⟨"'"(⊣∾˜∾)'⋄'∾MapNames⌾⋈𝕨⋄""⋄""⟩∾ >𝕩}¨⊢˝¨¨fields
    assembled ← headers ""⊸⋈⊸∾¨ bodys
    aliasLines←»⊸∨∘≠⟜' '⊸/¨<˘""‿" ← "‿" ⍝ "⟨MapNames,MapArgTypes,⊢⟩_MetaParse ⌽⌾(2⊸↑)˘>⊢˝¨aliases
    p←⊑¨⊢˝¨aliases
    ∾ ∾∾⟜(⋈⋈)¨⟜aliasLines⌾(¯1⊸↓)assembled⊔˜+`»+˝p≡⌜names
  }
  functionsDone ← {
    sLines ← 0¨functions

    returnTypes ← {funcName‿description‿retType‿args: retType}¨functions

    s2Lines ← 1¨returnTypes
    !¬∨´s2Lines∧sLines # I don't want the lines to collide

    [names⋄desc⋄returns⋄argTypes⋄argNames] ← {
      (3↑𝕩)∾⍉{<˘⍉(↕0‿2)∾´⊢˝¨<⁼𝕩}˘⊢˝𝕩
    }⍉(1+s2Lines∨sLines)/(↕0‿4)∾´functions

    sAllLinesExtended ← (↕∘≠⊸+⌾/↑˜+´+≠)s2Lines∨sLines
    s1LinesExtended‿s2LinesExtended ← s2Lines{((+´+≠)𝕩+𝕨)↑𝕨⊸{(¬𝕩∊/𝕨)/𝕩+↕≠𝕩}⌾/𝕨+𝕩}{𝔽⋈𝔽˜}sLines

    (»s2LinesExtended)⊸/<˘""‿" ← "‿" R('"‿" ("‿")) ⍝"‿" ⍝ "⟨
      ∾⟜"RAYLIB"¨⌾((»s2LinesExtended)⊸/)·∾⟜"Ref"¨⌾((0»s1LinesExtended)⊸/)MapNames¨
      ""¨⌾((»s2LinesExtended)⊸/) MapFuncReturnType # Returns
      ∾⟜"'"¨·∾⟜"RetPtr"¨⌾((»s2LinesExtended)⊸/)·∾⟜"Ref"¨⌾((0»s1LinesExtended)⊸/)MapNames¨ # Function Names
      { # Argument types
        returnTypes ← MapArgTypes returnTypes/˜1+s2Lines∨sLines
        a←returnTypes <∘{"('="≡3↑𝕩?"ptr"; "('>',"∾𝕩∾")"}⊸∾¨⌾(((" "⊸≢¨returnTypes)∧0»s2LinesExtended)⊸/) MapArgTypes¨𝕩
        b← (2⌊≠)◶⟨⋈"⍬"⋄⟨",⊂"⟩∾⊢⋄⊢⟩¨a
        (1↓·∾' '⊸∾¨)¨b
      }
      (∾' '⊸∾¨)¨ # Argument names turned into comments
      ⊢ # Function comment
    ⟩_MetaParse ⍉[names⋄returns⋄names⋄argTypes⋄argNames⋄desc]
  }
  1↓∾nl∾¨top∾bottom∾˜∨`⌾⌽∘≠⟜' '⊸/¨∾1↓∾⟨""⟩⊸⋈¨definesDone‿enumsDone‿structsDone‿functionsDone
}

⟨ParseHeader, ToPrettyJson⟩⇐•Import"../imports/c-header-to-bqn-ffi/parse.bqn"

HeaderToFFI ← ToFFI ParseHeader

GetFiles ← {𝕊libName:
  header ⇐ •FChars "include/"∾libName∾".h"
  autoErrorJson ⇐ •FChars "auto-error/"•file.At libName∾".json"
  replacementFilename ⇐ libName∾"Replacement.apln.hide"
  replacement ⇐ "../non-link"•file.At replacementFilename
  linkOutput ⇐ "../link/"•file.At libName∾".apln"
}

FFISetup ← {libName‿replacementFilename𝕊file:
  file ∾⟜("AfterDefaultDefinitions mode '"∾replacementFilename∾"'"∾@+10)⌾(∾⟜"∇"⁼)↩
  file ∾˜↩ ":Namespace "∾libName∾@+10
  file ∾ ↩ ":EndNamespace"∾˜@+10
  file ∾ ↩ @+10
}

HandleEverything ⇐ {libPrefix𝕊libName:
  ⟨ header ⋄ autoErrorJson ⋄ replacementFilename
    replacement ⋄ linkOutput
  ⟩← GetFiles libName
  ·‿·‿·‿·‿·‿functions ← headerTree ← libPrefix ParseHeader header

  replacement •FLines libName‿autoErrorJson MakeReplacement ⍉(⍋⊏˘)⊸⊏(↕0‿5)∾´functions
  linkOutput •FChars libName‿replacementFilename FFISetup ToFFI headerTree
  •Out linkOutput∾" successfully generated"
}

MakeReplacement ← {libName‿jsonFile𝕊[names⋄comment⋄outType⋄argNames⋄argTypes]:
  out←⟨⟩

  scopes‿functions ← "scopes"‿"functions"{⊐⟜𝕗}⊸⊏˝ParseJSON jsonFile

  [begin⋄end⋄nested⋄scopeDoc] ← {
    ⍉(↕0‿4)∾´⊐⟜𝕩⊸⊏˝¨scopes
  }"begin"‿"end"‿"nested"‿"doc"
  nested ⊐˜↩ "false"⋈○<"true" # Turn json booleans into binary

  [name⋄allow⋄disallow⋄funcDoc] ← ⍋∘⊏⊸(⊏⎉1) {
    ⍉(↕0‿4)∾´⊐⟜𝕩⊸⊏˝¨functions
  }"name"‿"allowed cases"‿"disallowed cases"‿"doc"

  # Define Assert. Needed for erroring
  out ∾↩<"Assert ← {⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}"

  # Defining scope status variables
  @∘{𝕊⟨b⟩:
    out∾↩<"scope"∾b∾" ← 0"
  }˘⍉[begin]

  # Spacing to separate variable definitions section from Tradfns definition
  out∾↩""‿""

  # When the first argument is a pointer, it's usually a reference as return value.
  # Useful since if first arg is a pointer, the function has a return value.
  returnViaRef ← '*'={⊢´⊑𝕩∾<" "}¨argTypes

  # Adding Tradfns with assertions
  @∘{𝕊⟨n,aw,daw,an,r⟩:
    arg ← "_"⍟(0=≠)1↓∾' '∾¨an
    out∾↩<'∇'∾"r←"⊸∾⍟r n∾(' '⊸∾"("∾⁼∾⟜")"⁼)⍟(×∘≠∧∧´∘≠⟜' ') ('('∾∾⟜')')⍟(×≠) arg
    {𝕊:out∾↩<"    '"∾n∾" errored' Assert ∨/"∾𝕩}⍟(¬"()"⊸≡) "("∾")"∾˜3↓∾{") ("∾3↓∾" ∧ scope"⊸∾¨𝕩}¨aw
    {𝕊:out∾↩<"    '"∾n∾" errored' Assert ∧/"∾𝕩}⍟(¬"()"⊸≡) "("∾")"∾˜3↓∾{") ("∾3↓∾" ∨ scope"⊸∾¨𝕩}¨daw
    {𝕊:out∾↩<"    '"∾n∾" errored' Assert ~scope"∾⊑1⊑𝕩⋄!1≡≠1⊑𝕩}⍟(¬∧´∘⊑)(n⊸≡¨begin)⊸/¨nested‿begin
    {𝕊:out∾↩<"    scope"∾𝕩∾" ← 1"}∘⊑⍟(×≠) begin/˜n⊸≡¨begin
    {𝕊:out∾↩<"    scope"∾𝕩∾" ← 0"}∘⊑⍟(×≠) begin/˜n⊸≡¨end
    out∾↩"∇"⋈˜"    "∾(r⊑"_←"‿"r←")∾ (n∾"RAYLIB")∾ (¬×∘≠∧∧´∘≠⟜' ')◶⟨' '⊸∾⋄'('∾∾⟜')'⟩ arg

  }˘⍉ [
    name
    allow
    disallow
    argNames
    returnViaRef∨"void"⊸≢¨outtype
  ]

  out∾˜↩(":Namespace "∾libName∾"Replacement")‿""
  out∾↩""‿":EndNamespace"

  out # Return value
}
